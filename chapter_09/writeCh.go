package main

import (
	"fmt"
	"time"
)

/*
 * 함수 매개변수를 채널로 선언하기 위해 chan 키워드를 붙였다. 그 뒤에는 반드시 채널의 타입(int)을 명시해야 한다.
 */
func writeToChannel(c chan int, x int) {
	fmt.Println(x)
	// x라는 값을 c라는 채널로 쓴다고 명시했다.
	c <- x
	// close() 함수로 채널을 닫았다. 다시 말해 close()가 호출된 뒤에는 더 이상 통신할 수 없다.
	close(c)
	// fmt.Println(x) 문장은 실행될 수 없다. 채널의 작동 원리를 생각하면 그 이유는 간단하다.
	// c라는 채널에 쓴 값을 아무도 읽지 않기 때문에 writeChannel() 함수의 실행은 'c <- x'라는
	// 문장에서 막혀버리기 때문이다. 따라서 time.Sleep(1 * time.Second)라는 문장이 끝나면
	// 프로그램은 더 이상 writeChannel()을 기다리지 않고 종료해버린다.
	fmt.Println(x)
}

/*
 * '채널(Channel)'이란?
 * ==> 주로 Go 루틴끼리 데이터를 주고 받기 위해 사용하는 통신 메커니즘이다. 그런데 여기에 몇 가지 규칙이 명확하게 정의되어 있다.
 * 1) 각 채널마다 특정한 데이터 타입으로만 데이터를 교환할 수 있다. 이를 그 채널의 '원소 타입(Element Type)'이라 부른다.
 * 2) 채널이 정상적으로 작동하려면 채널로 데이터를 보내는 상대방이 있어야 한다. 채널을 새로 선언하는 문장은 chan 키워드로 표시
 *    하고, 채널을 닫으려면 close() 함수를 호출해야 한다.
 * 3) 채널을 함수의 매개변수로 사용할 때 반드시 채널의 방향, 다시 말해 데이터를 보낼 채널인지 아니면 받을 채널인지를 명시해야
 *    한다는 것이다. 채널의 용도를 미리 알고 있다면 최대한 이 규칙을 따라 작성해야 한다. 그래야 데이터를 받는 채널에 실수로
 *    데이터를 보내거나 그 반대로 하는 일을 방지할 수 있어서 프로그램을 보다 안전하고 견고하게 만들 수 있다. 따라서 읽기 전용으로
 *    선언한 채널 타입의 함수 매개변수에 값을 쓰면 에러 메시지가 발생해서 잡기 힘든 버그가 발생할 가능성을 최대한 줄일 수 있다.
 */
func main() {
	// c라는 이름의 채널 변수를 정의하고 있다. 그리고 이 장에서 처음으로 make() 함수와 chan이란 키워드를 사용했다.
	// 모든 채널은 항상 타입을 가져야 한다.
	c := make(chan int)

	go writeToChannel(c, 10)
	time.Sleep(1 * time.Second)
}

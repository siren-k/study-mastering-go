package main

import (
	"fmt"
	"time"
)

func function() {
	for i := 0; i < 10; i++ {
		fmt.Print(i)
	}
	fmt.Println()
}

/*
 * '프로세스(Process)'란
 * ==> 명령어와 사용자 데이터, 시스템 영역, 그리고 실행 과정에 수집한 다양한 종류의 리소스로 구성된 독립적인
 * 실행 단위다. 반면 프로그램(Program)은 이러한 프로세스의 명령어와 사용자 데이터를 초기화하는데 사용할 명령어와
 * 데이터를 담은 파일이다.
 *
 * '스레드(Thread)'란
 * ==> 프로그램이나 프로세스보다 좀 더 가볍고 작은 실행 단위다. 스레드는 프로세스에 의해 생성되며 독립적인 제어
 * 흐름과 스택을 갖는다. 스레드와 프로세스의 차이를 한 마디로 표현하면, 프로세스는 바이너리 파일을 실행한 것이고,
 * 스레드는 프로세스의 일부분이라고 볼 수 있다.
 *
 * 'Go 루틴(Goroutine)'이란
 * ==> Go 프로그램에서 동시에 실행할 수 있는 최소 단위다. 여기서 최소라는 표현이 굉장히 중요하다. Go 루틴은
 * 유닉스 프로세스처럼 독립적인 개체가 아니다. 유닉스 프로세스 안에 살고 있는 스레드 안에서 존재한다. Go 루틴의
 * 가장 큰 장점은 굉장히 가벼워서 수천 내지 수만 개를 구동해도 아무런 문제가 없다.
 *
 * Go 루틴은 스레드보다 가벼워서 좋다. 당연히 프로세스보다 가볍다. 실전에서 하나의 프로세스는 여러 개의 스레드로
 * 구성할 뿐만 아니라, 그 안에 여러 Go 루틴으로 구성된다. 단, Go 루틴은 특정한 프로세스 환경이 있어야 존재할
 * 수 있다. 따라서 Go 루틴을 생성하려면 최소한 한 개 이상의 스레드를 가진 프로세스가 필요하다. 프로세스와 스레드는
 * 유닉스에서 관리해주지만, Go 루틴은 Go 언어와 개발자가 관리해줘야 한다.
 *
 * Go 스케줄러
 * ==> 유닉스 커널 스케줄러는 프로그램에 있는 스레드를 실행하는 일을 담당한다. 한편 Go 런타임에도 자체적으로
 * 스케줄러가 있는데, 여기서는 Go 루틴을 실행하는 일을 담당한다. Go 스케줄러는 'm:n 스케줄링'이라 부르는
 * 테크닝을 사용한다. 여기서 m은 실행되는 Go 루틴의 개수고, n은 Go 루틴을 '멀티플렉싱(Multiplexing)'할
 * OS의 스레드 개수다. Go 스케줄러는 Go 런타임의 구성 요소로서 Go 프로그램을 구성하는 Go 루틴을 실행시킬 방법과
 * 순서를 정한다. 따라서 Go 프로그래밍 언어에서 Go 스케줄러의 역할은 정말 중요하다. Go 프로그램에 있는 모든
 * 요소는 Go 루틴 형태로 실행되기 때문이다.
 *
 * 여기서 명심할 점은, Go 스케줄러는 한 프로그램 안에 있는 Go 루틴만 다루기 때문에 커널의 스케줄러에 비해 휠씬
 * 간결하고, 효율적이고, 빠르게 작동한다는 점이다.
 *
 * 동시성과 병렬성
 * 흔히 '동시성(Concurrency)'과 '병렬성(Parallelism)'을 같은 개념으로 생각하는 경우가 많은데, 절대로
 * 그렇지 않다. 병렬성은 특정한 종류의 개체들이 동시에 실행되는 것을 가리키는 반면, 동시성은 가능하다면 서로
 * 독립적으로 실행할 수 있도록 컴포넌트의 구조를 구성하는 방식을 뜻한다.
 *
 * 소프트웨어를 병렬로 실행하시 위해서는 먼저 그 소프트웨어에서 동시성을 지원하도록 구성해야 하며, 그것도 OS와
 * 하드웨어에서 지원해야만 가능하다. 참고로 '얼래(Erlang)이란 프로그래밍 언어는 아주 오래 전, 여러 코어로
 * 구성된 CPU가 등장하고 RAM의 용량도 커지기 훨씬 전부터 동시성을 지원했다.
 *
 * 동시성 설계가 제대로 된 시스템이라면 동시성을 갖춘 개체를 추가할수록 병렬로 실행할 수 있는 일이 늘어나기 때문에
 * 전반적인 시스템의 처리 속도가 빨라진다. 따라서 문제를 동시성의 관점에서 잘 표현하고 구현해야만 병렬성을 제대로
 * 실현할 수 있다. 따라서 개발자는 시스템의 설계 단계부터 동시성을 고려해야 하며, 또한 그렇게 함으로써 시스템의
 * 구성 요소에 대한 병렬성을 최대로 높일 수 있다. 그러므로 개발자는 병렬성을 고민할게 아니라, 원래 풀려던 문제를
 * 효율적으로 해결할 수 있도록 시스템을 최대한 독립적인 구성 요소로 나눌 방법을 고민해야 한다.
 *
 * 설사 여러분이 구현한 함수들을 병렬로 실행하는 기능을 유닉스 머신에서 제대로 지원하지 못하더라도, 동시성을 제대로
 * 반영하여 설계해두면 프로그램의 설계와 유지 보수성도 더욱 향상시킬 수 있다. 다시 말해, 병렬성보다 동시성이 더욱
 * 중요하다.
 */
func main() {
	// Go 루틴을 정의하려면 함수 이름이나 익명 함수를 정의하는 문장 앞에 go 키워드를 적으면 된다. 함수를
	// 호출하는 문자 앞에 go 키워드를 붙이면 그 함수는 즉시 리턴하고, 실제 동작은 백그라운드에서 Go 루틴
	// 형태로 실행하면서 원래 수행하던 프로그램 흐름은 계속 이어진다.
	//
	// Go 루틴을 생성하기 위한 두 가지 방법
	// 1) 일반 함수를 이용하는 것
	// 2) 익명 함수를 이용하는 것
	// ==> 실행할 함수의 크기가 작은 편이라면 이렇게 작성하는 것이 가장 좋다. 하지만 함수를 구성하는 코드의
	//     양이 많다면 일반 함수로 정의한 다음 go 키워드를 붙여 호출하는 것이 좋다.
	go function()

	go func() {
		for i := 0; i < 20; i++ {
			fmt.Print(i, " ")
		}
		fmt.Println()
	}()

	time.Sleep(1 * time.Second)

	// Go 루틴이 실제로 실행되는 순서를 예측할 수 없다. OS의 스케줄러와 Go 런타임의 스케줄러와 현재 OS의
	// 부하량에 따라 얼마든지 달라질 수 있기 때문이다.
	//
	// ❯ go run simple.go
	// 0123456789
	// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
	// ❯ go run simple.go
	// 0 1 2 3 4 5 6 7 8 9 0123456789
	// 10 11 12 13 14 15 16 17 18 19
}

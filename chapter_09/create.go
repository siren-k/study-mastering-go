package main

import (
	"flag"
	"fmt"
	"time"
)

func main() {
	// 커맨드라인 옵션으로 전달된 값을 담은 n을 읽는다. 이 값에 따라 생성할 Go 루틴의 개수를 결정한다.
	n := flag.Int("n", 10, "Number of goroutines")
	flag.Parse()

	count := *n
	fmt.Printf("Going to create %d goroutines.\n", count)

	// 원하는 수만큼 Go 루틴을 생성하는 부분은 for 루프로 작성한다.
	// 여기서도 마찬가지로 Go 루틴이 실제로 생성되고 실해되는 순서는 예측할 수 없다.
	for i := 0; i < count; i++ {
		go func(x int) {
			fmt.Printf("%d ", x)
		}(i)
	}

	// time.Sleep()을 호출한 이유는 앞에서 생성한 Go 루틴들이 모두 작업을 마칠 때까지 기다릴 시간을
	// 충분히 주기 위해서다. 그래야 전체 Go 루틴의 결과를 화면에 출력할 수 있다. 실전에서는 이렇게
	// time.Sleep()을 호출할 일이 없다. 각 Go 루틴이 최대한 빨리 마칠 수 있게 해야 할 뿐만 아니라
	// 이렇게 main() 함수를 리턴하기 전에 각각의 Go 루틴이 마칠 때까지 기다리게 하는 더 나은 기법이
	// 있기 때문이다.
	time.Sleep(time.Second)
	fmt.Println("\nExiting...")

	// ❯ go run create.go -n 100
	// Going to create 100 goroutines.
	// 13 0 1 2 3 4 5 6 7 8 9 10 11 12 25 21 22 23 24 45 32 20 14 15 16 17 18 19 60 46 47 48 33 34 31 36 50 38 35 51 49 29 30 55 52 53 54 57 56 37 58 40 59 41 42 76 68 26 43 74 62 65 75 27 63 81 61 39 90 78 94 97 44 71 67 69 87 93 82 83 88 92 84 72 77 73 85 99 70 28 91 86 79 80 66 96 98 95 89 64
	// Exiting...
	// ❯ go run create.go -n 100
	// Going to create 100 goroutines.
	// 3 0 1 2 14 6 7 8 9 10 11 12 13 4 18 15 16 17 21 22 19 5 23 24 25 31 26 27 28 29 30 35 32 33 34 37 36 38 46 39 40 41 44 45 50 47 49 42 52 51 53 54 56 55 57 43 64 20 61 59 60 62 63 69 68 70 65 66 72 74 78 77 79 83 81 67 86 82 92 88 58 94 75 80 85 71 97 73 89 87 96 48 93 95 84 91 90 76 99 98
}

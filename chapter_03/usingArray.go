package main

import (
	"fmt"
)

func main() {
	// 배열 3개를 정의
	// 3차원을 넘어가면 이해하기 힘들고 버그가 발생하기 쉽기 때문에 특별한 이유가 없는 한 2차원 이하로만 사용하는 것이 좋다.
	//
	// Go 언에서 제공하는 배열의 단점 ==> 이러한 단점으로 인해 Go 언어에서는 배열을 거의 사용하지 않는다. 따라서 이러한 문제를 피하려면 슬라이스를 사용하는 것이 좋다.
	//   1) 배열을 정의한 후에는 크기를 변경할 수 없다.
	//      ==> 기존 배열에 원소를 추가하고 싶은데 공간이 모자라면, 더 큰 변수를 생성한 뒤에 기존 배열에 담긴 원소들을 모두 새 배열에 복사해야 한다.
	//   2) 함수의 매개변수로 배열을 전달할 때 내부적으로는 그 배열의 복사본이 전달된다.
	//      ==> 함수가 종료된 후에는 함수 안에서 변경한 내용이 사라진다.
	//   3) 크기가 큰 배열을 함수에 전달하면 속도가 상당히 느려진다.
	//      ==> 배열을 복사해서 생성하기 때문이다.
	anArray := [4]int{1, 2, 4, -4}
	twoD := [4][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}
	threeD := [2][2][2]int{{{1, 0}, {-2, 4}}, {{5, -1}, {7, 0}}}

	fmt.Println("The length of", anArray, "is", len(anArray))
	fmt.Println("The first element of", twoD, "is", twoD[0][0])
	fmt.Println("The length of", threeD, "is", len(threeD))

	// 배열의 모든 원소에 접근하기 위해서는 배열의 차원 수만큼 for문을 작성해야 한다.
	// 이 규칙은 슬라이스에 대해서도 똑같이 적용된다.
	for i := 0; i < len(threeD); i++ {
		v := threeD[i]
		for j := 0; j < len(v); j++ {
			m := v[j]
			for k := 0; k < len(m); k++ {
				fmt.Print(m[k], " ")
			}
		}
		fmt.Println()
	}

	// range 키워드는 앞의 코드에서 for 루프에 사용한 반복 변수와 하는 일은 같지만
	// 코드를 좀 더 세련되고 깔끔하게 표현할 수 있다.
	//
	// range 키워드는 맵에서도 사용할 수 있다. 맵에 대해 반복할 때는 이 키워드를
	// 사용하는 것이 훨씬 간편하고 바람직하다.
	for _, v := range threeD {
		for _, m := range v {
			for _, s := range m {
				fmt.Print(s, " ")
			}
		}
		fmt.Println()
	}
}

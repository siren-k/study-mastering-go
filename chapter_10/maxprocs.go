package main

import (
	"fmt"
	"runtime"
)

func getGOMAXPROCS() int {
	// GOMAXPROCS 환경 변수(와 Go 함수)를 이용하면 유저 레벨(User-Level) Go 코드를 동시에 실행할 수
	// 있는 OS 스레드의 수를 제한할 수 있다. Go 1.5 버전부터 GOMAXPROCS에 대한 디폴트 값은 현재 사용하느
	// 유닉스 머신의 코어 수에 따라 결정된다.
	//
	// 현재 사용하는 머신의 코어 수보다 적은 값을 GOMAXPROCS 변수에 할당하면 프로그램 성능에 영향을 미칠 수
	// 있다. 또한 현재 사용할 수 있는 코어의 개수보다 큰 값을 GOMAXPROCS에 할당한다고 해서 프로그램 속도가
	// 반드시 빨라진다는 법도 없다.
	return runtime.GOMAXPROCS(0)
}

/*
 * '스케줄러(Scheduler)는 현재 사용할 수 있는 리소스만으로 처리할 수 있는 일의 양을 효율적으로 분산하는 역할을
 * 담당한다. Go 런타임은 m:n 스케줄러을 이용해 (OS 스레드보다 훨씬 가벼우면서 OS 스레드에 기반한) Go 루틴을
 * 스테줄링한다.
 *
 * Go 런타임은 '포크-조인 동시성(Fork-Join Concurrency) 모델을 사용한다. 이 모델의 포그 부분은 프로그램을
 * 실행하다가 임의의 시점에 자식 브랜치를 생성하는 것을 포함한다. 마찬가지로 Go 동시성 모델에서 조인 부분은 자식
 * 브랜치가 끝나서 부모와 합류하는 것을 나타낸다. 그 중에서도 특히, sync.Wait() 문장과 Go 루틴의 결과를 수집한
 * 채널이 조인 지점이 된다. 반면 Go 루틴이 새로 생성되면서 자식 브랜치가 생성된다.
 *
 * '균등 스케줄링 전략(Fair Scheduling Strategy)은 모든 부하를 현재 사용할 수 있는 프로세서로 고르게 나누는
 * 방식으로, 상당히 직관적이고 구현도 간단한 편이다. 얼핏 보면 모든 프로세서를 골고루 사용하면서 고려할 것도 많지
 * 않아 완벽한 전략인 것처럼 보일 수 있다. 하지만 실제로는 그렇지 않다. 분산 태스크의 상당 수는 다른 태스트에 의존
 * 하기 때문이다. 따라서 결국 충분히 활용되지 않거나 다른 프로세서보다 더 많이 사용하는 프로세서가 존재하게 된다.
 *
 * Go 언어에서 Go 루틴은 일종의 태스크(Task)인 반면, 이러한 Go 루틴을 호출하는 문장은 모두 '컨티뉴에이션
 * (Continuation)'이다. Go 스케줄러에서 사용하는 '작업 훔치기 전략(Work Stealing Strategy)'에 따르면,
 * 충분히 활용되지 않고 있는 (논리적인) 프로세서에게 줄 작업을 다른 프로세서에서 찾는다. 이에 맞는 작업을 발견하면
 * 그 프로세서로부터 훔쳐 오기 때문에 작업 훔치기 전략이라 부른다. 또한 Go 언어에서 사용하는 작업 훔치기 알고리즘은
 * 컨티뉴에이션을 훔쳐서 큐에 저장한다. '스톨링 조인(Stalling Join)'이란 이름에서 알 수 있듯이, 스레드의 실행이
 * 조인에서 멈춰서 다른 할 일을 찾기 시작하는 지점이다. 작업 훔치기와 컨티뉴에이션 훔치기는 모두 스톨링 조인이 발생하지만
 * 작업(태스트) 보다는 컨니튜에이션에서 더 많이 발생한다. 따라서 Go 언어의 알고리즘은 태스크보다는 컨티뉴에이션에 대해
 * 처리한다.
 *
 * 컨티뉴에이션 훔치기의 가장 큰 단점은 프로그래밍 언어의 컴파일러에서 부가적인 작업을 해야 한다는 것이다. 다행히 Go
 * 언어에서는 이러한 기능을 제공하기 때문에 작업 훔치기 알고리즘을 수행할 때 '컨티뉴에이션(Continuation Stealing)'
 * 을 사용한다. 컨티뉴에이션 훔치기의 장점 중 하나는 함수만 사용하거나 여러 Go 루틴으로 구성된 스레드 하나만 사용할
 * 때 결과가 같다는 것이다. 어떤 경우든지 주어진 시점에 단 하나만 실해되기 때문에 당연하다고 볼 수 있다.
 *
 * 이제 Go 언어에서 사용하는 m:n 스케줄링 알고리즘에 대한 얘기로 다시 돌아가보자. 엄밀히 말해 언제든지 m개의 Go
 * 루틴이 구동하면, n개의 OS 스레드에서 스케줄링할 대상이 된다. 이 때 논리적인 프로세서를 최대 GOMAXPROCS개 사용
 * 한다. GOMAXPROCS에 대해서는 잠시 후 자세히 설명한다.
 *
 * Go 스케줄러는 크게 세 종류의 개체 즉 현재 사용하는 OS에 대한 OS 스레드(M), Go 루틴(G), 논리적인 프로세서(P)에
 * 의해 작동된다. Go 프로그램에서 사용할 수 있는 프로세서의 수는 GOMAXPROCS 환경 변수로 지정한다. 따라서 항상
 * 최대 GOMAXPROCS 개의 프로세스가 존재한다.
 *
 *      글로벌 큐에 있는 Go 루틴을 실행하려면 논리적인 프로세서의 큐에 할당해야 한다. 따라서 Go 스케줄러는 각각의
 *      논리적인 프로세서의 로컬 큐에만 존재하는 Go 루틴을 실행시키지 않도록 글로벌 큐도 항상 확인해야 한다. 하지만
 *      이러한 글로벌 큐는 항상 검사할 필요가 없다. 다시 말해 로컬 큐보다 항상 우선 순위가 높지 않다. 또한 각각의
 *      논리적인 프로세서마다 여러 개의 스레드를 가지고 있을 수 있기 때문에, 현재 사용할 수 있는 논리적인 프로세서에
 *      대한 로컬 큐 사이에 훔치기가 발생할 수 있다. 마지막으로 Go 스케줄러는 필요에 따라 OS 스레드를 더 생성할
 *      수 있다. 하지만 OS 스레드는 상당히 무거운 편이다. 다시 말해 처리해야 할 OS 스레드가 너무 많으면 Go
 *      애플리케이션의 속도가 느려진다.
 *
 *      한 가지 명심할 점은, 프로그램에서 Go 루틴을 많이 사용한다고 해서 성능이 무조건 향상되지 않는다는 것이다.
 *      Go 루틴의 수도 많고, sync.Add(), sync.Wait(), sync.Done()을 호출하는 횟수도 많으면 Go 스케줄러에서
 *      처리해야 할 부가적인 작업이 늘어나서 프로그램 속도가 떨어질 수 있다.
 *
 */
func main() {
	fmt.Printf("GOMAXPROCS: %d\n", getGOMAXPROCS())
}
